import { Logger } from "winston";

export interface Auth {
  userId: number;
  userEmail: string;
  userScopes: string[];
}

/**
 * Static, serializable context about what's currently going on.
 * These should always be available in backend systems.
 */
export interface SafContext {
  /*
   * Format: "{uuid}"
   * Generated by request instantiators server-side, so things like reverse proxies, async job services,
   * and http servers which are directly accessible by clients. Generally, grpc and http servers receive
   * a request ID and should use it to correlate requests across processes.
   */
  requestId: string;

  /*
   * Format: "{service}.{subsystem}"
   * e.g. api.http or api.grpc.
   * The former name should match the docker service and npm package name, the latter should match a file in the package folder.
   */
  serviceName: string;

  /*
   * Format: "{method_name}"
   * e.g. "GetUser", such as operationId in OpenAPI, or rpc name in gRPC
   */
  operationName: string;

  /*
   * If the request is backed by an authenticated user, this will be set.
   * More info should be gotten directly from the auth service.
   */
  auth?: Auth;
}

/**
 * Clients for reporting various sorts of telemetry. They're expected to be instantiated with a SafContext,
 * so that context is included.
 */
export interface SafReporters {
  /*
   * The generic logger to use for this context. This is for leveled, message logs, for monitoring and debugging.
   */
  log: Logger;

  // TODO: Product Events
  // TODO: Errors

  // Note: Metrics and spans are not expected to ever be included here. Libraries and services should
  // instantiate them and use them on their own. However! These reporters are expected to contribute
  // to spans, by adding product events, logs, and exceptions to spans. They don't currently do this, though.
}

/**
 * Convenience type for when the context needs to have auth.
 */
export interface SafContextWithAuth extends SafContext {
  auth: Auth;
}
