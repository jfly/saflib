# Routes

Routes are the main source in packages which depend on `@saflib/express`. They are strongly typed, using types generated by separate `spec` packages which depend on `@saflib/openapi`.

For clarity, a **route** is the specification. The **handler** (or "route handler") is the implementation.

## File Organization

Route handlers should be organized in directories by their route prefix. For example [identity route handlers](https://github.com/sderickson/saflib/tree/f1864114bbd38b20996ea0dfe486767dff42d3b2/identity/identity-service/routes) are divided into `users` and `auth` folders based on their [OpenAPI-specified paths](https://github.com/sderickson/saflib/blob/f1864114bbd38b20996ea0dfe486767dff42d3b2/identity/identity-spec/openapi.yaml).

Each handler (e.g. get, list, create, update, delete) should reside in its own file per [best practice](../../best-practices.md#keep-files-small).

An `index.ts` file within each domain directory aggregates the individual handlers into an [Express Router](https://expressjs.com/en/5x/api.html#router). This router should include a response from [`createPreMiddleware`](https://github.com/sderickson/saflib/blob/e75a8597ae497ea8d422dab1a1e96f41792b85ba/express/src/middleware/composition.ts#L22), scoped to the route prefix. The router should handle the entire route path and be able to slot into an Express app without any further path qualification.

> TODO: Update index routers to actually handle the entire route path.

## Typing

Spec packages provide types for route requests and responses. Every handler must use these types to highlight as quickly as possible when the implementation does not match the specification.

Spec libraries export utility types with API route [operationIds](https://swagger.io/docs/specification/v3_0/paths-and-operations/#operationid) and status codes as keys for easy access. It is up to the handler to use and enforce those types.

Examples:

- [forgot-password.ts](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/identity/identity-service/routes/auth/forgot-password.ts)
- [resend-verification.ts](https://github.com/sderickson/saflib/blob/2025-08-13-update-docs/identity/identity-service/routes/auth/resend-verification.ts).

> TODO: Make sure all identity routes properly type their requests, responses.

## Wrapping

Each handler should be wrapped with `createHandler`. It just promisify's the handler, ensuring any uncaught exceptions get passed to `next`. More functionality may be added there such as more advanced typing, instrumentation, so it's important to have this intermediary around all handlers.

## Error Handling

It is up to the handler to have somewhere in it a return for every specified HTTP response code in the spec, except for 401s because those are handled by `@saflib/express`'s middleware. The handler should be the _only_ place where HTTP responses, successful or otherwise, are created or type checked. Essentially, it is the sole responsibility of the HTTP handler function to handle HTTP concerns.

There should be no try/catches in an HTTP handler. All unsafe operations made by the handler should return an error or a response, per [best practices](../../best-practices.md#return-errors). Those errors should be mapped to the appropriate HTTP error response code and body. If any exceptions are thrown, error middleware will catch it and it will be treated appropriately as a 5xx.

Handlers may report errors in any of the following ways:

1. `throw` an error created with [`https-errors`](https://www.npmjs.com/package/http-errors)'s `createError` function.
2. Call `next` with an `http-error` error.
3. Respond directly (`res.status(code).json({} satisfies ResponseBodyType);`), same as for successful responses.

The vast majority of errors responses should simply be [the error object](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/openapi/schemas/error.yaml) specified in `@saflib/openapi`. Error middleware will always respond with this structure, and so you can only use 1. and 2. if your spec adheres to the common error response object. If you need a custom error object, you will have to use option 3.

Note that `message` is _for debugging_. The `message` is _not_ intended to be shown to end users as part of normal use; it is not localized. Instead, the frontend should use the HTTP status and, if necessary, the `code` field to decide what to render to the user. The `@saflib/vue-spa` package in fact logs the message and [only propagates](https://github.com/sderickson/saflib/blob/e75a8597ae497ea8d422dab1a1e96f41792b85ba/vue-spa/src/tanstack.ts#L63-L67) the http status and response code fields to Vue components. All SDKs should do the same.

> TODO: Make sure message is actually console logged.

See for example [get-profile.ts](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/identity/identity-service/routes/auth/get-profile.ts).

## Implementation Basics

- **Error Handling Philosophy:**
  - Route handlers should **handle expected errors** returned by service/database layers (e.g., "Not Found", "Validation Failed"). This typically involves checking the `error` property of the returned object (see `ReturnsError` pattern).
  - Handlers translate these expected errors into appropriate HTTP status codes and response bodies (conforming to the OpenAPI spec).
  - **For queries that currently never return errors, use a `switch (true)` with a `throw error satisfies never;` in the `default` case. This ensures TypeScript will catch unhandled error types if the DB/service layer ever starts returning them.**
  - **Unexpected errors** (database connection issues, bugs, errors _thrown_ by services) should _not_ be caught by `try/catch` in the handler. Let them propagate; `createHandler` will catch them and pass them to the central error middleware, typically resulting in a 500 response.
- Routes are primarily responsible for HTTP concerns: request validation (basic format), authorization checks, context extraction, calling service/DB layer, response formatting (mapping results/errors to HTTP status/body), and adhering to the API contract (OpenAPI spec).
- Note that openapi validation and auth middleware checks happen before, so routes should assume params, body, and auth are valid. A handler need never throw a 401, but they could throw 403s.
- Keep business logic out of route handlers; place it in separate library or database layer functions.

## Route Handler Structure

Each route handler should be in its own file (e.g., `routes/auth/login.ts`) and follow this pattern:

```typescript
import { createHandler } from "@saflib/express";
import { asyncLocalStorage } from "../../context.ts";
import type { ApiRequest, ApiResponse } from "@your-org/your-spec"; // Adjust spec import
import {
  UserNotFoundError,
  InvalidCredentialsError,
} from "@your-org/your-db-package"; // Adjust error imports
import createError from "http-errors"; // For creating standard HTTP errors

export const loginHandler = createHandler(async (req, res) => {
  // Get context
  const ctx = asyncLocalStorage.getStore()!;

  // Validate and type the request body according to the spec
  // Basic validation might happen here or in middleware
  const loginRequest: ApiRequest["loginUser"] = req.body;

  // Call the appropriate service/DB function
  const { result: user, error } = await ctx.db.user.authenticate(loginRequest);

  // Handle expected errors returned by the service/DB layer
  if (error) {
    switch (true) {
      case error instanceof UserNotFoundError:
      case error instanceof InvalidCredentialsError:
        throw createError(404);
      default:
        // If an unexpected error type was *returned* (should be rare),
        // throw it so the central error handler catches it.
        // This ensures all error types from the DB layer are handled.
        throw error satisfies never;
    }
  }

  // If successful, send a typed 200 response conforming to the spec
  const response: ApiResponse["loginUser"][200] = {
    user: { id: user.id, email: user.email /* ... other fields */ },
    token: "jwt.token.here", // Assuming token generation happens here or is returned by authenticate
  };
  res.status(200).json(response);
});
```

## Route Organization

Create a router file within each feature directory (e.g., `routes/auth/index.ts`) to combine handlers for that feature:

```typescript
// routes/auth/index.ts
import express from "express";
import { loginHandler } from "./login.ts";
import { registerHandler } from "./register.ts";
// Import other auth handlers...

const router = express.Router();

// Define routes for the auth feature
router.post("/login", loginHandler);
router.post("/register", registerHandler);
// Add other auth routes...

export { router as authRouter };
```

Mount these feature routers in the main app file (`http.ts`), as shown in [Setup](./01-setup.md).

## Error Handling Examples

The `createHandler` wrapper simplifies error handling by catching unhandled promise rejections and thrown errors.

**Handling Expected Errors (Returned by Service/DB):**

```typescript
import { createHandler } from "@saflib/express";
import { asyncLocalStorage } from "../../context.ts";
import type { ApiRequest, ApiResponse } from "@your-org/your-spec";
import { CallSeriesNotFoundError } from "@your-org/your-db-package";
import createError from "http-errors";

export const getCallSeriesHandler = createHandler(async (req, res) => {
  const ctx = asyncLocalStorage.getStore()!;
  const { auth } = getSafContextWithAuth();
  const callSeriesId = parseInt(req.params.id);

  const { result: callSeries, error } =
    await ctx.db.callSeries.get(callSeriesId);

  if (error) {
    switch (true) {
      case error instanceof CallSeriesNotFoundError:
        throw createError(404);
      default:
        // If an unexpected error type was *returned* (should be rare),
        // throw it so the central error handler catches it.
        // This ensures all error types from the DB layer are handled.
        throw error satisfies never;
    }
  }

  // Check Authorization (Example)
  if (callSeries.ownerId !== auth.userId) {
    throw createError(403);
  }

  const response: ApiResponse["getCallSeries"][200] = {
    call_series: {
      /* map db result to api spec */
    },
  };
  res.status(200).json(response);
});
```

**For queries that currently never return errors:**

```typescript
const { result, error } = await mainDb.contacts.create(ctx.dbKey, input);
if (error) {
  switch (true) {
    default:
      throw error satisfies never;
  }
}
```

## Best Practices

1.  **HTTP Focus:** Handlers manage HTTP request/response lifecycle.
2.  **Separate Business Logic:** Place core logic in service/DB layers.
3.  **Use OpenAPI Types:** Ensure handlers conform to the API contract.
    - Type request bodies, parameters, and responses using generated types.
    - Adhere to specified success and error response schemas.
4.  **Error Handling:** Handle _expected_ errors returned from services by mapping them to appropriate HTTP responses. Let _unexpected_ errors (thrown) propagate to the central error handler via `createHandler`.
5.  **File Structure:** Follow the "one handler per file" structure within feature directories.
